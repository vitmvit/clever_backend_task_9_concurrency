# clever_backend_task_9_concurrency

## Задача
1. Создать любой gradle проект
2. Придерживаться GitFlow: master -> develop -> feature/fix
3. Создать два класса:

    * Клиент - имеет список данных в виде List<Integer> от 1 до n.  Отдельными потоками, по случайному индексу из списка выбирается значение (метод remove()) и в виде запроса (класс с int -полем), содержащего это значение, отправляется на сервер в асинхронном режиме (например отправляются со случайной задержкой между запросами - диапазон - от 100 до 500 мс). Количество запросов равно размеру первоначального списка. Контроль: после отправки всех запросов размер списка данных = 0
     
    * Сервер - получает запросы от клиента. Метод обрабатывающий запрос имеет задержку в виде рандомного инта. Диапазон - от 100 до 1000 мс. Сервер обрабатывает запросы, используя общий для всех потоков ресурс: List<Integer>, в который складываются значения приходящие с запросом. В ответ от сервера передаем размер листа на момент формирования ответа (класс с int-полем). Итоговый контроль правильности данных на стороне сервера: список (общий ресурс) должен содержать значения от 1 до n без пробелов, повторений, размерность его должна составлять n
 4. Клиент получает от сервера ответ и в общий для всех потоков ресурс accumulator суммирует значение из ответа от сервера. Итоговый контроль: accumulator = (1+n) * (n/2). Т.е. для диапазона 1-100 ответ должен быть 5050
 5. Протестировать эти два класса с проверкой многопоточности
 6. Протестировать взаимодействие клиента - сервера отдельным тестом (интеграционный) - обязательно
 7. В реализации использовать классы пакета java.util.concurrent (обязательно Lock, Callable, Executor, Future, остальное - по выбору)
 8. Методы класса Object (относящиеся к потокам и монитору) и ключевое слово synchronized НЕ использовать
